1)
pozdrav
Kdo se už někdy setkal s obfuskací?
Proč jim o tom vykládám? - Byla to moje bakalářka.

2)
vysvětlit že jsem práci dělal v Brně
Co bylo celková náplň práce?
Co mě přimělo si zvolit takové téma? - chtěl jsem si napsat překladač svého jazyka
Jak to souvisí s obfuskací? - prostor pro vyzkoušení netradičních technik

3)
Jak to dopadlo? - Tedy co vlastně byly výstupy té práce

- Překladač
    dle zadání jsem vytvořil vlastní programovací jazyk
    (NAPSAT NA TABULI) Jabukód - popsat jak to vzniklo

- Generující cílový kód
    Je to na bázi C (ze zadání), proto binárka
    výstupem je binární kód, ačkoli je více možností obfuskace (zdrojový, mezikód, binární kód)

- Odolný proti zpětné analýze
    gró práce - produkovat chráněný binární kód přímo jako výstup překladu
    Kromě už zaběhlých metod jsem také implementoval určité, které jsem si sám navrhl. Obojí vám tady dneska představím a popíšu.

4)
Ve své práci jsem měl teoretickou část, ale to už asi znáte, tak to přeskočíme a přejdeme na to zajímavé.
POSLAT VÝTISK - obfuskace je kapitola 5 a v přílohách je celá gramatika
              - Pokud by někdo měl nějaké otázky i k tomu, jak jsem to implementoval, neváhejte se zeptat.

- Nejprve z opačné strany -
    - Proč se chceme věnovat zpětné analýze? - postrádáme znalosti - není dokumentace, tvůrce ji nechce sdílet
                                                - ve vývoji - znovupoužitelnost
                                                - bezpečnost - odhalování skrytých hrozeb

- Jak to děláme? - disaseblery, debuggery, dekompilátory,
                   tracing nástroje (strace, perf), patching nástroje, dumping nástroje (readelf, objdump, crash)
    popsat JAK FUNGUJÍ a K ČEMU SLOUŽÍ

5)
- Z toho co jsem popsal je zřejmé, že se potřebujeme zpětné analýze i bránit
    - ochrana intelektuálního vlastnictví
    - identifikace škodlivého kódu

- dokonalá ochrana je nemožná
    - Cíl je ji učinit nerealistickou

- řada metod - odstraňování symbolických informací, šifrování kódu, antidebugging, Saas - důvěryhodný nativní kód, HLAVNĚ obfuskace
    popsat JAK FUNGUJÍ a K ČEMU SLOUŽÍ

6)
Popsat jednotlivé části definice
- Proč je obfuskace lepší? - je robustnější, silnější a není tak principielně jednoduchá
- pozorovatelné chování - můžeme mít vedlejší efekty

7)
ke každému druhy uvést nějaké příklady a v čem se liší
zmínit ezo obfuskátory (JSFuck, MOVfuscator) - zeptat se jestli o nich někdo slyšel a setkal se s nima
Znáte někdo nějaké další ezo obfuskátory?

8)
síla - míra přidané složitosti pro analýzu
skrytost - obfuskace se obtížně identifukuje a její princip je obtížně pochopitelný
odolnost - obfuskace se obtížně odstraňuje

cena - zpomalení, zvětšení binárního souboru, množství alokované paměti

9)
rozlišujeme jisté základní členění
výpočetní transformace - složitější struktura a horší převoditelnost do vysokoúrovňové reprezentace
seksupovací transformace - úplné odstranění vysokoúrovňových konstrukcí daného jazyka
transformace pořadí - změna pořadí instrukcí či bloku pro zhoršení pochopitelnosti

transformace dat - upravují uložení, zpracování a interpretaci dat programu

10 a dále)
teď už ty samotné obfuskace - mezi obecně používané tady také zařadím
pár těch které jsem si sám navrhl

---

VÝPOČETNÍ

opaque predicates
    - kód je převzat z binary_search.jk !!!

vkládání mrtvého kódu 
    - mrtvý kod v kontextu skutečného kódu
        - kombinace s opaque predicates
klonování kódu
    - UKÁZAT PŘÍKLAD

SESKUPOVACÍ

Úprava cyklů

zploštění toku řízení
    - nejprve vykreslit koncept základních bloků
    - NAKRESLIT

POŘADÍ

prokládání kódu
    - JE TAM TEN MEME !!!
    - PŘÍKLAD

TR. DAT

změna kódování - i šifrování
změna struktury dat - u mě polí, UKÁZAT (binary_search.jk)
expanze literálů - UKÁZAT (write_int.jk)
rozšíření podmínek
redundantí parametry funkcí

NETRADIČNÍ

Optimalizacemi
    Střídání instrukcí
    Inlining A OUTLINING (VÝPOČETNÍ TR.)
    Optimální algoritmy
    Paralelizace kódu - může či nemusí skutečně paralelizovat

Symbolické informace
    Odstranění knihovních volání
        - Zmínit že to bylo na REVECH !!!
        - asi vždy přítomny, nelze je měnit
    Šifrování
    Kódovaná pojmenování
        - má význam hlavně při manuální analýze
    Falšování symbolických informací
        - UKÁZAT NA fact.jk

Obfuskace znaménkovosti
    - TABULKU NA TABULI
        - ZF == 1            - ==
        - SF == OF / CF == 0 - <
        - SF != OF / CF == 1 - >

    - kód je součást fibonacci.jk, pouze hlavička for cyklu
    - COUNT je globální proměnná v sekci .data
    - klíčová část je změněné znaménko skoku
    - zmínit kvalitu v kombinaci s prokládáním !

Jazyk samotný
    foreach
    redo
    restart
    - PROČ TO JE DOBRÉ - ZMÍNIT REDUCIBILITU CFG
    - dekompilátory ty konstrukce nerozeznají

    - UKÁZAT PŘÍKLAD VYUŽITÍ - bubble_sort.jk

---

-1)
děkuji za pozornost
Teď já mám otázku na vás, jaké máte se zpětnou analýzou zkušenosti vy?
